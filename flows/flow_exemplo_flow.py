#!/usr/bin/env python
"""
GUIA DE CONSTRU√á√ÉO DE FLOWS NO CREWAI

Este arquivo serve como um guia did√°tico para a constru√ß√£o de flows no CrewAI,
demonstrando as melhores pr√°ticas e padr√µes de implementa√ß√£o.

Um flow no CrewAI representa um fluxo de trabalho ass√≠ncrono que:
1. Define um estado estruturado para compartilhar informa√ß√µes entre etapas
2. Organiza a execu√ß√£o em etapas sequenciais ou paralelas
3. Integra diferentes componentes (crews, agentes, tarefas, ferramentas)
4. Processa informa√ß√µes de forma modular e escal√°vel

Este exemplo demonstra a integra√ß√£o completa entre todos os componentes do projeto.
"""

# [BLOCO 1] - IMPORTS E CONFIGURA√á√ÉO INICIAL
# ------------------------------------------------------
# Sempre organize seus imports em blocos l√≥gicos:
# 1. Bibliotecas padr√£o do Python
# 2. Bibliotecas de terceiros
# 3. M√≥dulos locais do projeto

# Bibliotecas padr√£o do Python
import os
import sys
import random
from typing import Dict, Any

# Bibliotecas de terceiros
from pydantic import BaseModel, Field
from dotenv import load_dotenv
from crewai.flow.flow import Flow, listen, start, or_, and_, router

# Configura√ß√£o de caminhos para imports relativos
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
sys.path.append(project_root)

# Imports locais do projeto
from crews.crew_exemplo.crew_exemplo_crew import metodo_de_execucao_da_crew
from crews.crew_exemplo_2.crew_exemplo_2_crew import metodo_de_execucao_da_crew_2
from crews.crew_relatorio.crew_relatorio_crew import executar_crew_relatorio

# Carrega vari√°veis de ambiente
load_dotenv()

# [BLOCO 2] - MODELAGEM DO ESTADO DO FLOW
# ------------------------------------------------------
# O estado do flow √© fundamental para compartilhar informa√ß√µes entre etapas.
# Use Pydantic para criar um modelo estruturado com valida√ß√£o autom√°tica.

class FlowExemploState(BaseModel):
    """Estado estruturado para o Flow de Exemplo.
    
    Um bom modelo de estado deve:
    1. Documentar claramente cada campo
    2. Definir valores padr√£o quando apropriado
    3. Usar tipos espec√≠ficos para garantir valida√ß√£o
    4. Incluir todos os dados que precisam ser compartilhados entre etapas
    """
    # Dados de entrada do flow
    topico: str = Field(description="T√≥pico principal para pesquisa e an√°lise")
    info_externa_1: str = Field(description="Informa√ß√£o externa adicional para contexto")
    info_externa_2: str = Field(default="", description="Segunda informa√ß√£o externa para contexto")
    info_externa_3: str = Field(default="", description="Terceira informa√ß√£o externa para contexto")
    
    # Resultados das crews
    resultado_crew_exemplo: dict = Field(default={}, description="Resultado da execu√ß√£o da crew exemplo")
    resultado_crew_exemplo_2: dict = Field(default={}, description="Resultado da execu√ß√£o da crew exemplo 2")
    relatorio_final: str = Field(default="", description="Relat√≥rio final gerado pela crew de relat√≥rio")
    
    # Controle de fluxo condicional
    processamento_complexo: bool = Field(default=False, description="Flag para determinar se deve usar processamento complexo")
    validacao_aprovada: bool = Field(default=False, description="Flag para indicar se a valida√ß√£o foi aprovada")
    tipo_processamento: str = Field(default="", description="Tipo de processamento escolhido pelo router")
    
    # Logs de controle de fluxo
    logs_or: list = Field(default_factory=list, description="Logs dos m√©todos executados via OR")
    logs_and: list = Field(default_factory=list, description="Logs dos m√©todos executados via AND")
    logs_router: list = Field(default_factory=list, description="Logs das decis√µes do router")

# [BLOCO 3] - IMPLEMENTA√á√ÉO DO FLOW
# ------------------------------------------------------
# A classe do flow herda de Flow e implementa os m√©todos necess√°rios
# para definir o fluxo de execu√ß√£o.

class FlowExemplo(Flow):
    """
    Flow did√°tico que demonstra como integrar todos os componentes do CrewAI.
    
    Estrutura do flow:
    1. Inicializa√ß√£o e configura√ß√£o do estado (@Flow.start)
    2. Prepara√ß√£o de informa√ß√µes para a crew (@Flow.listen)
    3. Execu√ß√£o da crew_exemplo (@Flow.listen)
    4. Gera√ß√£o de relat√≥rio final com agente e ferramenta (@Flow.listen)
    5. Finaliza√ß√£o e entrega do resultado (@Flow.listen)
    
    Cada etapa √© implementada como um m√©todo ass√≠ncrono decorado adequadamente.
    """
    
    def __init__(self):
        """Inicializa o flow de exemplo integrado com crew_exemplo."""
        super().__init__()
        
    @start()
    async def iniciar_flow(self) -> Dict[str, Any]:
        """
        Ponto de entrada do flow.
        
        O m√©todo decorado com @start() √© sempre o primeiro a ser executado.
        Ele acessa o estado atrav√©s de self.state e deve retornar um estado 
        atualizado para as pr√≥ximas etapas.
        
        Returns:
            Estado estruturado convertido para dicion√°rio.
        """
        # [DICA 1] - ACESSO AO ESTADO
        # M√©todos @start() acessam o estado atrav√©s de self.state
        # O estado j√° foi inicializado pelo m√©todo kickoff() com os inputs fornecidos
        current_state = self.state if isinstance(self.state, dict) else self.state.__dict__
        
        # [DICA 2] - CONVERS√ÉO DE ESTADO
        # Converta o estado n√£o estruturado (dicion√°rio) para um objeto Pydantic
        # Isso garante valida√ß√£o autom√°tica e acesso estruturado aos dados
        flow_state = FlowExemploState(
            # Use get() com valores padr√£o para lidar com entradas ausentes
            topico=current_state.get("topico", "[T√≥pico n√£o especificado]"),
            # Voc√™ pode usar valores de entrada para construir outros campos
            info_externa_1=current_state.get("info_externa_1", f"Contexto inicial sobre {current_state.get('topico', '[T√≥pico]')}")
        )
        
        # [DICA 3] - LOGGING CLARO
        # Use emojis e mensagens claras para facilitar o acompanhamento do flow
        print(f"üöÄ [FLOW EXEMPLO] Iniciando com t√≥pico: '{flow_state.topico}'")
        
        # [DICA 4] - RETORNO DE ESTADO
        # Sempre converta o objeto Pydantic de volta para dicion√°rio ao retornar
        return flow_state.model_dump()
    
    @listen("iniciar_flow")
    async def preparar_informacoes_externas(self, state: Dict[str, Any]) -> Dict[str, Any]:
        """
        Prepara informa√ß√µes externas para a crew_exemplo.
        
        O decorador @listen("metodo_anterior") indica que este m√©todo
        deve ser executado ap√≥s a conclus√£o do m√©todo especificado.
        
        Args:
            state: Estado atual do flow (dicion√°rio).
            
        Returns:
            Estado atualizado com informa√ß√µes externas preparadas.
        """
        # [DICA 4] - RECONSTRU√á√ÉO DE ESTADO
        # Reconstrua o objeto Pydantic a partir do dicion√°rio recebido
        flow_state = FlowExemploState(**state)
        
        print(f"üìã [FLOW EXEMPLO] Preparando informa√ß√µes para: '{flow_state.topico}'")
        
        # [DICA 5] - PROCESSAMENTO DE DADOS
        # Aqui voc√™ pode realizar qualquer processamento necess√°rio antes de chamar a crew
        # Por exemplo: buscar dados externos, formatar informa√ß√µes, etc.
        
        # Neste exemplo, estamos apenas criando informa√ß√µes de demonstra√ß√£o
        # Em um caso real, estas informa√ß√µes viriam de fontes externas ou processamento
        flow_state.info_externa_1 = f"Contexto principal sobre '{flow_state.topico}'"
        flow_state.info_externa_2 = f"Dados complementares relacionados a '{flow_state.topico}'"
        flow_state.info_externa_3 = f"Informa√ß√µes adicionais relevantes para '{flow_state.topico}'"
        
        print("‚úÖ [FLOW EXEMPLO] Informa√ß√µes preparadas com sucesso")
        
        # Sempre retorne o estado atualizado como dicion√°rio
        return flow_state.model_dump()
    
    @listen("preparar_informacoes_externas")
    async def executar_crew_exemplo(self, state: Dict[str, Any]) -> Dict[str, Any]:
        """
        Executa a crew_exemplo com as informa√ß√µes preparadas.
        
        Esta etapa demonstra como integrar uma crew existente dentro de um flow,
        permitindo a composi√ß√£o de fluxos complexos a partir de componentes reutiliz√°veis.
        
        Args:
            state: Estado atual do flow com informa√ß√µes externas.
            
        Returns:
            Estado atualizado com os resultados da crew_exemplo.
        """
        # Reconstrua o objeto de estado
        flow_state = FlowExemploState(**state)
        
        print(f"ü§ñ [FLOW EXEMPLO] Executando crew_exemplo para: '{flow_state.topico}'")
        
        # [DICA 6] - INTEGRA√á√ÉO COM CREWS
        # Ao integrar crews em flows, voc√™ pode:
        # 1. Chamar um m√©todo de execu√ß√£o da crew (como neste exemplo)  
        # 2. Instanciar e executar a crew diretamente
        # 3. Usar uma abordagem h√≠brida com configura√ß√£o din√¢mica
        
        try:
            # Executa a crew_exemplo com as informa√ß√µes preparadas
            resultado_crew = metodo_de_execucao_da_crew(
                info_externa_1=flow_state.info_externa_1,
                info_externa_2=flow_state.info_externa_2,
                info_externa_3=flow_state.info_externa_3
            )
            
            # Atualiza o estado com os resultados da crew
            flow_state.resultado_crew_exemplo = resultado_crew
            
            print("‚úÖ [FLOW EXEMPLO] Crew exemplo executada com sucesso")
            
        except Exception as e:
            # [DICA 7] - TRATAMENTO DE ERROS
            # Sempre trate poss√≠veis erros para evitar que o flow inteiro falhe
            print(f"‚ùå [FLOW EXEMPLO] Erro ao executar crew exemplo: {str(e)}")
            # Em caso de erro, podemos fornecer um resultado padr√£o ou alternativo
            flow_state.resultado_crew_exemplo = {"erro": str(e), "resultado_alternativo": "Dados de fallback"}
        
        return flow_state.model_dump()
    
    @listen("executar_crew_exemplo")
    async def executar_crew_exemplo_2(self, state: Dict[str, Any]) -> Dict[str, Any]:
        """
        Executa a crew_exemplo_2 com an√°lise complexa dos dados.
        
        Esta etapa demonstra como executar m√∫ltiplas crews em sequ√™ncia,
        permitindo processamento mais complexo e especializado dos dados.
        
        Args:
            state: Estado atual do flow com os resultados da crew_exemplo.
            
        Returns:
            Estado atualizado com os resultados da crew_exemplo_2.
        """
        flow_state = FlowExemploState(**state)
        
        print(f"üî¨ [FLOW EXEMPLO] Executando crew_exemplo_2 para an√°lise complexa: '{flow_state.topico}'")
        
        try:
            # Executa a crew_exemplo_2 com dados complexos baseados nos resultados anteriores
            resultado_crew_2 = metodo_de_execucao_da_crew_2(
                dados_complexos=str(flow_state.resultado_crew_exemplo),
                contexto_adicional=flow_state.info_externa_1,
                parametros_tecnicos=f"An√°lise t√©cnica de: {flow_state.topico}"
            )
            
            # Atualiza o estado com os resultados da segunda crew
            flow_state.resultado_crew_exemplo_2 = resultado_crew_2
            
            print("‚úÖ [FLOW EXEMPLO] Crew exemplo 2 executada com sucesso")
            
        except Exception as e:
            print(f"‚ùå [FLOW EXEMPLO] Erro ao executar crew exemplo 2: {str(e)}")
            flow_state.resultado_crew_exemplo_2 = {"erro": str(e), "resultado_alternativo": "An√°lise complexa indispon√≠vel"}
        
        return flow_state.model_dump()
    
    @listen("executar_crew_exemplo_2")
    async def gerar_relatorio_final(self, state: Dict[str, Any]) -> Dict[str, Any]:
        """
        Gera um relat√≥rio final consolidando os resultados de m√∫ltiplas crews.
        
        Esta etapa demonstra como integrar crews especializadas dentro de um flow,
        consolidando resultados de m√∫ltiplas execu√ß√µes em um relat√≥rio final.
        
        Args:
            state: Estado atual do flow com os resultados de ambas as crews.
            
        Returns:
            Estado atualizado com o relat√≥rio final consolidado.
        """
        flow_state = FlowExemploState(**state)
        
        print(f"üìù [FLOW EXEMPLO] Gerando relat√≥rio final consolidado para: '{flow_state.topico}'")
        
        try:
            # [DICA 8] - INTEGRA√á√ÉO COM CREW ESPECIALIZADA
            # Consolida os resultados de m√∫ltiplas crews para o relat√≥rio final
            dados_consolidados = {
                "crew_exemplo": flow_state.resultado_crew_exemplo,
                "crew_exemplo_2": flow_state.resultado_crew_exemplo_2,
                "topico": flow_state.topico
            }
            
            resultado_relatorio = executar_crew_relatorio(
                dados_entrada=str(dados_consolidados),
                topico=flow_state.topico
            )
            
            # Extrai o conte√∫do do relat√≥rio do resultado da crew
            if hasattr(resultado_relatorio, 'raw'):
                flow_state.relatorio_final = resultado_relatorio.raw
            else:
                flow_state.relatorio_final = str(resultado_relatorio)
            
            print("‚úÖ [FLOW EXEMPLO] Relat√≥rio final gerado com sucesso")
            
        except Exception as e:
            print(f"‚ùå [FLOW EXEMPLO] Erro ao gerar relat√≥rio: {str(e)}")
            flow_state.relatorio_final = f"N√£o foi poss√≠vel gerar o relat√≥rio: {str(e)}"
        
        return flow_state.model_dump()
    
    # [BLOCO 3.5] - OPERADORES L√ìGICOS AVAN√áADOS
    # ------------------------------------------------------
    # Demonstra√ß√£o dos operadores OR, AND e ROUTER do CrewAI
    
    @listen("gerar_relatorio_final")
    async def avaliar_complexidade(self, state: Dict[str, Any]) -> Dict[str, Any]:
        """
        Avalia se o processamento deve ser complexo baseado no conte√∫do.
        
        Esta etapa demonstra como usar l√≥gica condicional para determinar
        o fluxo de execu√ß√£o baseado nos resultados anteriores.
        
        Args:
            state: Estado atual do flow com o relat√≥rio gerado.
            
        Returns:
            Estado atualizado com flags de controle de fluxo.
        """
        flow_state = FlowExemploState(**state)
        
        print("üîç [FLOW EXEMPLO] Avaliando complexidade do processamento...")
        
        # [DICA 13] - L√ìGICA CONDICIONAL BASEADA EM CONTE√öDO
        # Analisa o conte√∫do para determinar se precisa de processamento complexo
        relatorio_length = len(flow_state.relatorio_final)
        crew_1_length = len(str(flow_state.resultado_crew_exemplo))
        crew_2_length = len(str(flow_state.resultado_crew_exemplo_2))
        
        # Determina complexidade baseada no tamanho do conte√∫do
        total_content = relatorio_length + crew_1_length + crew_2_length
        flow_state.processamento_complexo = total_content > 1000  # Threshold arbitr√°rio
        
        # Simula uma valida√ß√£o aleat√≥ria para demonstrar o router
        flow_state.validacao_aprovada = random.choice([True, False])
        
        print(f"üìä Conte√∫do total: {total_content} caracteres")
        print(f"üîß Processamento complexo: {flow_state.processamento_complexo}")
        print(f"‚úÖ Valida√ß√£o aprovada: {flow_state.validacao_aprovada}")
        
        return flow_state.model_dump()
    
    @router("avaliar_complexidade")
    async def decidir_tipo_processamento(self, state: Dict[str, Any]) -> str:
        """
        Router que decide o tipo de processamento baseado na avalia√ß√£o.
        
        O decorator @router permite criar fluxos condicionais din√¢micos,
        direcionando a execu√ß√£o para diferentes caminhos baseado na l√≥gica de neg√≥cio.
        
        Args:
            state: Estado atual do flow.
            
        Returns:
            String indicando o caminho a seguir.
        """
        flow_state = FlowExemploState(**state)
        
        print("üéØ [ROUTER] Decidindo tipo de processamento...")
        
        # [DICA 14] - L√ìGICA DO ROUTER
        # O router permite criar m√∫ltiplos caminhos de execu√ß√£o
        if flow_state.processamento_complexo and flow_state.validacao_aprovada:
            flow_state.tipo_processamento = "complexo_aprovado"
            flow_state.logs_router.append("Escolhido: processamento complexo aprovado")
            print("üìà Direcionando para processamento complexo aprovado")
            return "complexo_aprovado"
        elif flow_state.processamento_complexo and not flow_state.validacao_aprovada:
            flow_state.tipo_processamento = "complexo_rejeitado"
            flow_state.logs_router.append("Escolhido: processamento complexo rejeitado")
            print("üìâ Direcionando para processamento complexo rejeitado")
            return "complexo_rejeitado"
        elif not flow_state.processamento_complexo and flow_state.validacao_aprovada:
            flow_state.tipo_processamento = "simples_aprovado"
            flow_state.logs_router.append("Escolhido: processamento simples aprovado")
            print("‚ú® Direcionando para processamento simples aprovado")
            return "simples_aprovado"
        else:
            flow_state.tipo_processamento = "simples_rejeitado"
            flow_state.logs_router.append("Escolhido: processamento simples rejeitado")
            print("‚ö° Direcionando para processamento simples rejeitado")
            return "simples_rejeitado"
    
    # [DEMONSTRA√á√ÉO DO OPERADOR OR]
    # O operador or_ executa quando QUALQUER um dos m√©todos especificados emite sa√≠da
    
    @listen("complexo_aprovado")
    async def processamento_avancado(self, state: Dict[str, Any]) -> Dict[str, Any]:
        """
        Processamento avan√ßado para casos complexos aprovados.
        """
        flow_state = FlowExemploState(**state)
        
        print("üöÄ [PROCESSAMENTO AVAN√áADO] Executando an√°lise detalhada...")
        flow_state.logs_or.append("Processamento avan√ßado executado")
        
        # Simula processamento avan√ßado
        import time
        time.sleep(0.5)  # Simula processamento
        
        return flow_state.model_dump()
    
    @listen("simples_aprovado")
    async def processamento_rapido(self, state: Dict[str, Any]) -> Dict[str, Any]:
        """
        Processamento r√°pido para casos simples aprovados.
        """
        flow_state = FlowExemploState(**state)
        
        print("‚ö° [PROCESSAMENTO R√ÅPIDO] Executando an√°lise b√°sica...")
        flow_state.logs_or.append("Processamento r√°pido executado")
        
        return flow_state.model_dump()
    
    @listen(or_("processamento_avancado", "processamento_rapido"))
    async def logger_processamento_aprovado(self, state: Dict[str, Any]) -> Dict[str, Any]:
        """
        Logger que executa quando QUALQUER processamento aprovado √© conclu√≠do.
        
        O operador or_ permite que este m√©todo seja executado quando
        processamento_avancado OU processamento_rapido emitir uma sa√≠da.
        
        Args:
            state: Estado atual do flow.
            
        Returns:
            Estado atualizado com logs.
        """
        flow_state = FlowExemploState(**state)
        
        print("üìù [LOGGER OR] Processamento aprovado conclu√≠do!")
        flow_state.logs_or.append("Logger OR: processamento aprovado registrado")
        
        return flow_state.model_dump()
    
    # [DEMONSTRA√á√ÉO DO OPERADOR AND]
    # O operador and_ executa apenas quando TODOS os m√©todos especificados emitiram sa√≠da
    
    @listen("complexo_rejeitado")
    async def analise_rejeicao_complexa(self, state: Dict[str, Any]) -> Dict[str, Any]:
        """
        An√°lise espec√≠fica para rejei√ß√µes em casos complexos.
        """
        flow_state = FlowExemploState(**state)
        
        print("üîç [AN√ÅLISE REJEI√á√ÉO] Analisando motivos da rejei√ß√£o complexa...")
        flow_state.logs_and.append("An√°lise de rejei√ß√£o complexa executada")
        
        return flow_state.model_dump()
    
    @listen("simples_rejeitado")
    async def analise_rejeicao_simples(self, state: Dict[str, Any]) -> Dict[str, Any]:
        """
        An√°lise espec√≠fica para rejei√ß√µes em casos simples.
        """
        flow_state = FlowExemploState(**state)
        
        print("üìã [AN√ÅLISE REJEI√á√ÉO] Analisando motivos da rejei√ß√£o simples...")
        flow_state.logs_and.append("An√°lise de rejei√ß√£o simples executada")
        
        return flow_state.model_dump()
    
    @listen(and_("analise_rejeicao_complexa", "analise_rejeicao_simples"))
    async def consolidar_analises_rejeicao(self, state: Dict[str, Any]) -> Dict[str, Any]:
        """
        Consolida an√°lises apenas quando AMBAS as an√°lises de rejei√ß√£o foram executadas.
        
        O operador and_ garante que este m√©todo s√≥ execute quando
        analise_rejeicao_complexa E analise_rejeicao_simples tiverem emitido sa√≠da.
        
        Args:
            state: Estado atual do flow.
            
        Returns:
            Estado atualizado com consolida√ß√£o.
        """
        flow_state = FlowExemploState(**state)
        
        print("üìä [CONSOLIDADOR AND] Consolidando todas as an√°lises de rejei√ß√£o...")
        flow_state.logs_and.append("Consolida√ß√£o AND: todas as an√°lises de rejei√ß√£o processadas")
        
        return flow_state.model_dump()
    
    @listen(or_("logger_processamento_aprovado", "consolidar_analises_rejeicao"))
    async def finalizar_flow(self, state: Dict[str, Any]) -> Dict[str, Any]:
        """
        Finaliza o flow e prepara a sa√≠da final.
        
        Esta √© a √∫ltima etapa do flow, respons√°vel por finalizar o processamento
        e preparar os dados para retorno ao chamador.
        
        Args:
            state: Estado atual do flow com o relat√≥rio final.
            
        Returns:
            Estado final do flow, pronto para ser retornado ao chamador.
        """
        flow_state = FlowExemploState(**state)
        
        # [DICA 11] - FINALIZA√á√ÉO DO FLOW
        # Use esta etapa para:
        # 1. Realizar limpezas necess√°rias
        # 2. Formatar os dados de sa√≠da
        # 3. Registrar m√©tricas ou logs finais
        # 4. Preparar o estado para retorno
        
        print(f"üèÅ [FLOW EXEMPLO] Finalizando flow para: '{flow_state.topico}'")
        
        # Exibe um resumo dos resultados (opcional)
        print("\n" + "="*50)
        print(f"RESUMO DO FLOW: '{flow_state.topico}'")
        print("="*50)
        print(f"Crew exemplo processada: {len(str(flow_state.resultado_crew_exemplo))} caracteres")
        print(f"Crew exemplo 2 processada: {len(str(flow_state.resultado_crew_exemplo_2))} caracteres")
        print(f"Tamanho do relat√≥rio: {len(str(flow_state.relatorio_final))} caracteres")
        print(f"Tipo de processamento: {flow_state.tipo_processamento}")
        print(f"Processamento complexo: {flow_state.processamento_complexo}")
        print(f"Valida√ß√£o aprovada: {flow_state.validacao_aprovada}")
        print(f"Logs OR executados: {len(flow_state.logs_or)}")
        print(f"Logs AND executados: {len(flow_state.logs_and)}")
        print(f"Decis√µes do Router: {len(flow_state.logs_router)}")
        print("="*50)
        
        # [DICA 15] - LOGS DETALHADOS DOS OPERADORES
        if flow_state.logs_or:
            print("\nüîÄ LOGS DO OPERADOR OR:")
            for i, log in enumerate(flow_state.logs_or, 1):
                print(f"  {i}. {log}")
        
        if flow_state.logs_and:
            print("\nüîó LOGS DO OPERADOR AND:")
            for i, log in enumerate(flow_state.logs_and, 1):
                print(f"  {i}. {log}")
        
        if flow_state.logs_router:
            print("\nüéØ LOGS DO ROUTER:")
            for i, log in enumerate(flow_state.logs_router, 1):
                print(f"  {i}. {log}")
        
        print("="*50)
        
        # [DICA 12] - RETORNO FINAL
        # O estado final deve conter todos os dados relevantes para o chamador
        return flow_state.model_dump()

# [BLOCO 4] - FUN√á√ïES AUXILIARES E PONTO DE ENTRADA
# ------------------------------------------------------
# Estas fun√ß√µes facilitam a execu√ß√£o e teste do flow

async def executar_flow_async(topico: str, **kwargs) -> Dict[str, Any]:
    """
    Fun√ß√£o auxiliar ass√≠ncrona para executar o flow com par√¢metros espec√≠ficos.
    
    Esta fun√ß√£o facilita a execu√ß√£o do flow a partir de outros m√≥dulos
    ou scripts, encapsulando a cria√ß√£o e execu√ß√£o do flow.
    
    Args:
        topico: O t√≥pico principal a ser processado pelo flow.
        **kwargs: Par√¢metros adicionais para o flow.
        
    Returns:
        Resultado da execu√ß√£o do flow.
    """
    # Instancia o flow
    flow = FlowExemplo()
    
    # Prepara os par√¢metros de entrada como state
    state = {"topico": topico}
    state.update(kwargs)  # Adiciona par√¢metros opcionais
    
    # Executa o flow e retorna o resultado
    return await flow.kickoff(state)

def executar_flow(topico: str, **kwargs) -> Dict[str, Any]:
    """
    Fun√ß√£o s√≠ncrona para executar o flow.
    
    Args:
        topico: O t√≥pico principal a ser processado pelo flow.
        **kwargs: Par√¢metros adicionais para o flow.
        
    Returns:
        Resultado da execu√ß√£o do flow.
    """
    # Instancia o flow
    flow = FlowExemplo()
    
    # Prepara os par√¢metros de entrada como state
    state = {"topico": topico}
    state.update(kwargs)  # Adiciona par√¢metros opcionais
    
    # Executa o flow usando o m√©todo s√≠ncrono kickoff
    # O CrewAI gerencia internamente o event loop
    return flow.kickoff(state)

def plot():
    """
    Gera uma visualiza√ß√£o HTML interativa do flow usando o m√©todo plot() do CrewAI.
    
    Esta fun√ß√£o cria uma representa√ß√£o gr√°fica do workflow que mostra:
    - N√≥s representando cada m√©todo/etapa do flow
    - Setas direcionadas indicando o fluxo de execu√ß√£o
    - Conex√µes entre m√©todos baseadas nos decoradores @listen, @router, or_, and_
    - Estrutura visual dos operadores l√≥gicos avan√ßados implementados
    
    O arquivo HTML gerado √© interativo, permitindo:
    - Zoom in/out para explorar detalhes
    - Hover sobre n√≥s para ver informa√ß√µes adicionais
    - Navega√ß√£o visual do fluxo de dados entre etapas
    
    Sa√≠da:
        Cria o arquivo "FlowExemploPlot.html" no diret√≥rio atual que pode ser
        aberto em qualquer navegador web para visualizar o flow completo.
        
    Uso:
        Esta visualiza√ß√£o √© especialmente √∫til para:
        - Entender a estrutura complexa dos operadores l√≥gicos (or_, and_, @router)
        - Debugar fluxos condicionais
        - Documentar workflows para apresenta√ß√µes
        - Identificar gargalos ou caminhos de execu√ß√£o
    """
    flow = FlowExemplo()
    flow.plot("FlowExemploPlot")

# Ponto de entrada para execu√ß√£o direta do script
if __name__ == "__main__":
    # [DICA 14] - EXECU√á√ÉO STANDALONE
    # Defina par√¢metros de exemplo para teste r√°pido do flow
    
    print("\n" + "="*70)
    print("GUIA DE CONSTRU√á√ÉO DE FLOWS NO CREWAI - EXEMPLO DID√ÅTICO")
    print("="*70)
    
    # Par√¢metros de exemplo para teste
    TOPICO_EXEMPLO = "Constru√ß√£o de Flows no CrewAI"
    INFO_ADICIONAL = "Foco em integra√ß√£o de componentes e boas pr√°ticas"
    
    # Executa o flow
    try:
        resultado = executar_flow(
            topico=TOPICO_EXEMPLO,
            info_externa_1=INFO_ADICIONAL
        )
        print("‚úÖ Flow executado com sucesso!")
        plot()
    except Exception as e:
        print(f"‚ùå Erro ao executar o flow: {str(e)}")
        import traceback
        traceback.print_exc()
        resultado = {"relatorio_final": f"Erro na execu√ß√£o: {str(e)}"}
    
    # Exibe o resultado final formatado
    print("\n" + "="*70)
    print(f"RESULTADO DO FLOW: '{TOPICO_EXEMPLO}'")
    print("="*70)
    print(resultado["relatorio_final"][:500] + "..." if len(resultado["relatorio_final"]) > 500 else resultado["relatorio_final"])
    print("\n[Relat√≥rio completo dispon√≠vel no resultado do flow]")
    print("="*70)
    
    print("\nüí° DICA: Este flow serve como um guia did√°tico para constru√ß√£o de flows no CrewAI.")
    print("üí° Estude o c√≥digo-fonte para entender as melhores pr√°ticas e padr√µes de implementa√ß√£o.")
    print("="*70)
